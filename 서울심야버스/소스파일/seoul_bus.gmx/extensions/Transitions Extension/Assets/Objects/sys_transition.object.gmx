<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables
// Transition Variables
next_room = noone;                      // Which room to go to
kind = transition.fade;                 // Which transition to use
xx = -1;                                // The players new X position (optional)
yy = -1;                                // The players new Y position (optional)
step = 0;                               // Current step of transition
time = 60;                              // Time the transition uses (optional)

// Fade Variables
alpha = 0;
fade = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Slide Effect Transition
// Surfaces
surf_start = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));
surf_end = surface_create(surface_get_width(application_surface),surface_get_height(application_surface));
    
surface_set_target(surf_start);
draw_clear(c_black);                                // Draw blank on surface
draw_enable_alphablend(false);                      // Removes alpha values, as image is opaque
draw_set_colour_write_enable(true,true,true,false); // Same as above
draw_surface(application_surface,0,0);              // Draws the first room onto surf_start
draw_set_colour_write_enable(true,true,true,true);  // Re-enable alpha
draw_enable_alphablend(true);                       // Same as above
surface_reset_target();                             // Reset the surface to application_surface
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stripe Effect Transition
stripes = 100;                              // Total amount of stripes
anim = false;                               // Used to change the time if needed
change = false;                             // True when half time has passed
height = view_hport[0] / stripes;           // Height of each stripe
width = view_wport[0] + (view_wport[0] / 5);// The width of each stripe
timer = -width;                             // Timer will work as the slowest stripe

// Define all necessary arrays
stripe_one[stripes] = 0;                    // X position for stripe on left side
stripe_two[stripes] = 0;                    // X position for stripe on right side
length[stripes] = 0;                        // Y position for each stripe
stripe_spd[stripes] = 0;                    // Random speed for each stripe

// Alarm is used to change the time to the new one and start transition
alarm[0] = 1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Expanding Circle Transition
circle_radius = 0.01;      // Circle Radius
circle_expand = true;      // Circle Expansion
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Delete surfaces
// This is done so there is no memory leak
surface_free(surf_start);
surface_free(surf_end);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stripe Effect - Finish array and start animation
switch (kind) {
    case transition.stripe_hor:
        // Get easy references for all port sizes
        x = view_xport[0];
        y = view_yport[0];
        var stripe_w = view_wport[0];
        var stripe_h = view_hport[0];
    
        for (var i = stripes; i &gt; 0; i--) {
            stripe_one[i] = x - width;
            stripe_two[i] = (x + stripe_w) + width;
            length[i] = i * (stripe_h / stripes);
            stripe_spd[i] = random_range(width / time, width / time + (time / 8));
        }
    break;
    case transition.stripe_ver:
        x = view_xport[0];
        y = view_yport[0];
        var stripe_w = view_wport[0];
        var stripe_h = view_hport[0];
    
        width = stripe_h + (stripe_h / 5);
        height = stripe_w / stripes;
        timer = y - width;
       
        for (var i = stripes; i &gt; 0; i--) {
            stripe_one[i] = y - width;
            stripe_two[i] = (y + stripe_h) + width;
            length[i] = i * (stripe_w / stripes);
            stripe_spd[i] = random_range(width / time, width / time + (time / 8));
        }
    break;
}

// Animation starts after this is true
anim = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Timer increase
// Make sure that stripe_hor and stripe_ver finish their animation properly
if (kind != transition.stripe_hor &amp;&amp; kind != transition.stripe_ver) {
    step++;
    
    if (step &gt; time) { instance_destroy(); }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Slide Effect Destroy
// If any of the surfaces don't exists, jump to the next room
if (kind == transition.left || kind == transition.right || kind == transition.up || kind == transition.down) {
    if (!surface_exists(surf_start) || !surface_exists(surf_end)) {
        if (room != next_room) { room_goto(next_room); }
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stripe Effect - Move the stripes
if (kind == transition.stripe_hor || kind == transition.stripe_ver) {
    if (anim) {
        // Moves each stripe with their individual speed. Same speed for left and right stripe
        for (var i = stripes; i &gt; 0; i--) {  
            stripe_one[i] += stripe_spd[i];
            stripe_two[i] -= stripe_spd[i];
        }
    
        // Increase timer
        timer += width / time;
        
        // Check if the transition is halfways done
        if (timer + width &gt; view_wport[0] / 2 &amp;&amp; !change) { 
            room_goto(next_room);
            change = true;
        }
        
        // Destroy instance if transition is done
        if (timer &gt; view_wport[0]) { instance_destroy(); }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Expanding Circle
if (kind == transition.circle) {
    var ww = display_get_gui_width() + (display_get_gui_width() / 6);

    if (circle_expand) { circle_radius += (ww / (time/2)); }
    if (circle_radius &gt;= ww &amp;&amp; circle_expand) { circle_expand = false; room_goto(next_room); }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Change room (Fade Transition)
room_goto(next_room);

// Only change player position if it has been said to change
//if (xx != -1) { obj_player.x = xx; }
//if (yy != -1) { obj_player.y = yy; }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update surfaces for Slide transition
if (kind == transition.left || kind == transition.right || kind == transition.up || kind == transition.down) {
    surface_set_target(surf_end);
    draw_clear(c_black);
    draw_enable_alphablend(false);
    draw_set_colour_write_enable(true,true,true,false);
    draw_surface(application_surface,0,0);
    draw_set_colour_write_enable(true,true,true,true);
    draw_enable_alphablend(true);
    surface_reset_target();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Transitions
// Temporary variables to have access to GUI Width and Height
var gui_width, gui_height, x1, y1, x2, y2;
gui_width = display_get_gui_width();
gui_height = display_get_gui_height();

// Choose what to draw depending on which "kind" it is
switch (kind) {
    case transition.fade:
        // Change room for Fade transition
        if (step == ceil(time/2)) { event_perform(ev_other, ev_user0); }
        
        // Positioning for the rectangle
        var ww, hh;
        x = view_xport[0];
        y = view_yport[0];
        gui_width = x + view_wport[0];
        gui_height = y + view_hport[0];
            
        // Color can be changed if wanted.
        draw_set_color(c_black);
        draw_set_alpha(1 - abs(step - (time/2)) / (time/2));
        draw_rectangle(x, y, gui_width, gui_height, false);
        draw_set_alpha(1);
    break;
    // Slide left
    case transition.left: 
        x1 = (1-step/time) * gui_width; y1 = 0; 
        x2 = (-step/time) * gui_width; y2 = 0;
    break;
    // Slide right
    case transition.right: 
        x1 = (-1+step/time) * gui_width; y1 = 0;
        x2 = (step/time) * gui_width; y2 = 0;
    break;
    // Slide up
    case transition.up: 
        x1 = 0; y1 = (1-step/time) * gui_height;
        x2 = 0; y2 = (-step/time) * gui_height;
    break;
    // Slide down
    case transition.down:
        x1 = 0; y1 = (-1+step/time) * gui_height;
        x2 = 0; y2 = (step/time) * gui_height;
    break;
    // Horizontal Stripes
    case transition.stripe_hor:
        // Sets the color. Can be changed
        draw_set_color(c_black);
        
        // Draws the stripes according to the already defined array variables
        for (var i = stripes; i &gt; 0; i--) {
            draw_rectangle(stripe_one[i], length[i], stripe_one[i] + width, length[i] - height, false);
            draw_rectangle(stripe_two[i], length[i], stripe_two[i] - width, length[i] - height, false);
        }
    break;
    // Vertical Stripes
    case transition.stripe_ver:
        // Sets the color. Can be changed
        draw_set_color(c_black);
    
        // Draws the stripes according to the already defined array variables
        for (var i = stripes; i &gt; 0; i--) {
            draw_rectangle(length[i], stripe_one[i], length[i] - height, stripe_one[i] + width, false);
            draw_rectangle(length[i], stripe_two[i], length[i] - height, stripe_two[i] - width, false);
        }
    break;
    case transition.circle: 
        // Color can be changed to fit your style
        draw_set_color(c_black);
        
        // Only fade out when the circle has expanded
        if (!circle_expand) { draw_set_alpha(1 - abs(step - (time/2)) / (time/2)); }
        draw_circle(gui_width / 2, gui_height / 2, circle_radius, false);
        draw_set_alpha(1);
    break;
}
   
// Drawing the surfaces for the left/right/up/down transitions.
if (kind == transition.left || kind == transition.right || kind == transition.up || kind == transition.down) {
    if (room != next_room) { room_goto(next_room); }
        
    draw_surface_stretched_ext(surf_end, x1, y1, gui_width, gui_height, c_white, 1);
    draw_surface_stretched_ext(surf_start, x2, y2, gui_width, gui_height, c_white, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
